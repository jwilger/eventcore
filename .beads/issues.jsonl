{"id":"eventcore-002","content_hash":"0f4414b42a627c8128199eef022b3778fad68ec22e705a8db444aea174b14bc4","title":"Automatic Retry with Sensible Defaults","description":"Add automatic retry on version conflicts so developers don't have to handle ConcurrencyError manually. Use hardcoded sensible defaults (5 retries, exponential backoff with jitter) that work for most cases.","design":"**Retry Logic**: Hardcoded exponential backoff (10ms, 20ms, 40ms, 80ms, 160ms), max 5 attempts, jitter to prevent thundering herd\n**Observability**: Basic logging of retry attempts and outcomes\n**Behavior**: ConcurrencyError triggers automatic retry instead of being returned to developer","acceptance_criteria":"See docs/PLANNING.md eventcore-002 acceptance criteria","notes":"## Testing Approach (2025-10-29)\n\n### Integration Tests (Library Consumer POV)\nTwo end-to-end scenarios testable from developer perspective:\n\n1. **Contention Resolved (Happy Path)**\n   - Given: Version conflict occurs during command execution\n   - When: execute() is called\n   - Then: Command automatically retries and succeeds\n   - Assertion: result.is_ok() - developer never sees ConcurrencyError\n   - Implementation: Use ControlledEventStore (from eventcore-001) to inject single conflict\n\n2. **Retries Exhausted (Max Attempts)**\n   - Given: Persistent conflicts (5+ failures)\n   - When: execute() is called\n   - Then: All 5 retry attempts exhausted\n   - Assertion: matches!(result, Err(CommandError::ConcurrencyError)) with retry context\n   - Implementation: ControlledEventStore injects conflicts on all attempts\n\n### Unit Tests (Implementation Details)\nThree lower-level tests for retry mechanics:\n\n3. **Backoff Timing**\n   - Verify exponential progression: 10ms, 20ms, 40ms, 80ms, 160ms\n   - Test at unit level (not integration test timing)\n\n4. **Jitter Randomness**\n   - Verify jitter adds ±20% random variation to backoff delays\n   - Prevents thundering herd\n   - Test at unit level\n\n5. **Logging Output**\n   - Verify log format: \"Retry attempt N/5 for stream X after Yms\"\n   - Verify final outcome logged\n   - Test as aspect of integration tests (not separate scenario)\n\n### Implementation Order\n1. Start with integration test #1 (contention resolved - simplest)\n2. Implement retry logic to make it pass\n3. Add integration test #2 (retries exhausted)\n4. Add unit tests #3-5 as needed during implementation\n\n### Key Insight\nLogging and jitter are cross-cutting concerns, not separate acceptance criteria.\nFocus on two core behaviors: retry succeeds OR retry exhausts.","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-10-22T09:59:52.383583474-07:00","updated_at":"2025-11-01T21:06:42.595768583-07:00","closed_at":"2025-11-01T21:06:42.595768583-07:00","source_repo":"."}
{"id":"eventcore-003","content_hash":"871fde17a9edbe7bc4d4373b01b72718a67ea0efeb6661dbaf3ae58215f0d022","title":"Configurable Retry Policies","description":"Enable library consumers to customize retry behavior for their specific workloads and observe retry patterns through metrics and tracing. RetryPolicy configuration with custom max attempts, backoff strategies, and advanced observability.","design":"**RetryPolicy Configuration**: Method chaining API for custom configuration, configurable max_retries and backoff strategies (Exponential with jitter, Fixed delay)\n**Testing Utilities**: RetryPolicy with max_retries(0) for disabling retry in tests, ConflictNTimesStore helper for deterministic conflict injection\n**Observability**: Consider metrics, tracing, and structured logging for retry operations (specific requirements determined during implementation)","acceptance_criteria":"See docs/PLANNING.md eventcore-003 acceptance criteria","status":"open","priority":1,"issue_type":"feature","assignee":"jwilger","created_at":"2025-10-22T09:59:52.635170763-07:00","updated_at":"2025-11-02T21:08:03.260630044-08:00","source_repo":".","dependencies":[{"issue_id":"eventcore-003","depends_on_id":"eventcore-002","type":"blocks","created_at":"2025-10-22T09:59:52.645026809-07:00","created_by":"daemon"}]}
{"id":"eventcore-004","content_hash":"ae860afd58982a3d12339ea3bd568aae1142579b427fa62cc77f5c5f8c9e9766","title":"Multi-Stream Atomic Commands","description":"Enable library consumers to create commands that atomically read from and write to multiple event streams - THE core value proposition of EventCore. Commands declare multiple streams, read from all declared streams, and write to multiple streams atomically with all-or-nothing semantics.","design":"**Multi-Stream Support**: Commands declare multiple stream IDs, executor reads all declared streams, state reconstruction from events across multiple streams, atomic write to all streams with per-stream version checking\n**Enhanced InMemoryEventStore**: Atomic append across multiple streams, version checking for all streams in single operation, all-or-nothing guarantee\n**Example**: TransferMoney command demonstrating atomic debit/credit\n**Observability**: Consider metrics, tracing, and structured logging for multi-stream operations (specific requirements determined during implementation)","acceptance_criteria":"See docs/PLANNING.md eventcore-004 acceptance criteria","status":"open","priority":1,"issue_type":"feature","created_at":"2025-10-22T09:59:52.878747571-07:00","updated_at":"2025-11-02T21:04:39.713613424-08:00","source_repo":".","dependencies":[{"issue_id":"eventcore-004","depends_on_id":"eventcore-002","type":"blocks","created_at":"2025-10-22T09:59:52.890959478-07:00","created_by":"daemon"}]}
{"id":"eventcore-005","content_hash":"b819c3b5a57fdd554b19a1f8659020cf0ba9d50c2f10fd58bd1f6616fa9dc5ef","title":"PostgreSQL Production Backend","description":"Enable library consumers to use production-ready PostgreSQL storage with ACID transactions for multi-stream atomicity. Separate eventcore-postgres crate implementing EventStore trait.","design":"**PostgreSQL Adapter**: Separate crate implementing EventStore trait, connection pooling (sqlx), ACID transaction support, JSON event serialization, schema migrations\n**Event Schema**: Events table with UUID primary keys, stream ID/version with unique constraint, JSONB event type/data/metadata, timestamp tracking, optimized indexes\n**Integration Tests**: Real PostgreSQL tests via Docker Compose, multi-stream atomicity with ACID, concurrent command tests\n**Observability**: Consider metrics, tracing, and structured logging for database operations (specific requirements determined during implementation)","acceptance_criteria":"See docs/PLANNING.md eventcore-005 acceptance criteria","status":"open","priority":1,"issue_type":"feature","created_at":"2025-10-22T09:59:53.147969784-07:00","updated_at":"2025-11-02T21:04:44.94221798-08:00","source_repo":".","dependencies":[{"issue_id":"eventcore-005","depends_on_id":"eventcore-004","type":"blocks","created_at":"2025-10-22T09:59:53.160209793-07:00","created_by":"daemon"},{"issue_id":"eventcore-005","depends_on_id":"eventcore-1","type":"blocks","created_at":"2025-10-29T12:31:06.583961977-07:00","created_by":"jwilger"}]}
{"id":"eventcore-006","content_hash":"0bb4af6f28896b85cdaec119a1ecb550d6c3719114c20267e205310e192e745c","title":"Command Derive Macro","description":"Eliminate infrastructure boilerplate by auto-generating CommandStreams trait implementation from #[stream] field attributes. Developers use #[derive(Command)] to generate all infrastructure code, leaving only domain logic to implement.","design":"**Procedural Macro**: Separate eventcore-macros crate with proc-macro, #[derive(Command)] generates CommandStreams trait, #[stream] field attribute marks stream fields, phantom types for compile-time stream access control\n**Developer Experience**: Before ~30 lines infrastructure, after ~5 lines with derive, focus only on apply/handle methods\n**Testing**: Macro expansion tests with trybuild, integration tests comparing macro vs manual implementation\n**Observability**: Consider metrics, tracing, and structured logging for macro-generated code (specific requirements determined during implementation)","acceptance_criteria":"See docs/PLANNING.md eventcore-006 acceptance criteria","status":"open","priority":2,"issue_type":"feature","created_at":"2025-10-22T09:59:53.39983429-07:00","updated_at":"2025-11-02T21:04:50.13372464-08:00","source_repo":".","dependencies":[{"issue_id":"eventcore-006","depends_on_id":"eventcore-004","type":"blocks","created_at":"2025-10-22T09:59:53.412440986-07:00","created_by":"daemon"}]}
{"id":"eventcore-007","content_hash":"f951e5d7f6ac692dd7e143d71506579b2ff1f8b7d337aa9e7b399ccfa493cd20","title":"Dynamic Stream Discovery","description":"Enable commands to discover additional streams at runtime based on state, supporting workflows where stream requirements depend on runtime data. StreamResolver trait allowing commands to examine initial state and declare additional streams with full atomicity maintained.","design":"**StreamResolver Trait**: Optional trait for commands with state-dependent streams, resolve_additional_streams(state) method, executor support for multi-pass discovery, incremental re-reading optimization\n**Discovery Integration**: Static streams declared with #[stream], dynamic streams discovered via resolver, all streams participate in atomicity, deduplication prevents re-reading same stream\n**Example**: ProcessPayment command discovering payment method streams\n**Observability**: Consider metrics, tracing, and structured logging for dynamic stream discovery (specific requirements determined during implementation)","acceptance_criteria":"See docs/PLANNING.md eventcore-007 acceptance criteria","status":"open","priority":2,"issue_type":"feature","created_at":"2025-10-22T09:59:53.677539911-07:00","updated_at":"2025-11-02T21:04:55.323768796-08:00","source_repo":".","dependencies":[{"issue_id":"eventcore-007","depends_on_id":"eventcore-004","type":"blocks","created_at":"2025-10-22T09:59:53.68792184-07:00","created_by":"daemon"},{"issue_id":"eventcore-007","depends_on_id":"eventcore-006","type":"blocks","created_at":"2025-10-22T09:59:53.689909474-07:00","created_by":"daemon"}]}
{"id":"eventcore-008","content_hash":"ee4b144b8ef21e445489ad44743e4cb5ff011e6d2359fdcc3313784172968e4e","title":"Basic Event Subscriptions","description":"Enable developers to subscribe to event streams and process events in order. Core subscription mechanism WITHOUT checkpointing (eventcore-009 adds that). EventSubscription trait allowing consumers to subscribe to streams and process events using poll-based or callback-based approach.","design":"**EventSubscription Trait**: subscribe(stream_ids) method returning event iterator/stream, delivers events in stream order, works with PostgreSQL and in-memory backends\n**Subscription Features**: Subscribe to one or more streams with pattern matching, process events to build read models, events delivered in order within each stream\n**Example**: AccountBalance projection showing simple read model (not restart-safe yet)\n**Observability**: Consider metrics, tracing, and structured logging for subscription operations (specific requirements determined during implementation)","acceptance_criteria":"See docs/PLANNING.md eventcore-008 acceptance criteria","status":"open","priority":2,"issue_type":"feature","created_at":"2025-10-22T09:59:53.969674847-07:00","updated_at":"2025-11-02T21:05:00.515963427-08:00","source_repo":".","dependencies":[{"issue_id":"eventcore-008","depends_on_id":"eventcore-005","type":"blocks","created_at":"2025-10-22T09:59:53.979602684-07:00","created_by":"daemon"}]}
{"id":"eventcore-009","content_hash":"bc1629dcdbe233e1741622cfd4e0c60f0c3005f0397101d3da90f95ad6b6e884","title":"Checkpointing for Subscriptions","description":"Add checkpoint storage and resume capability to subscriptions, enabling reliable projection rebuilding and restart safety. Checkpoint persistence allowing subscriptions to resume from last processed position after restart, making projections production-ready.","design":"**Checkpoint Storage**: save_checkpoint(subscription_id, position) method, load_checkpoint(subscription_id) returns last saved position, checkpoint stored alongside events, automatic checkpoint advancement\n**Resume from Checkpoint**: On restart load last checkpoint, events delivered from checkpoint position + 1, projection rebuilds only new events\n**Projection Rebuilding**: Reset checkpoint to version 0 for complete rebuild, replay all historical events\n**Observability**: Consider metrics, tracing, and structured logging for checkpoint operations (specific requirements determined during implementation)","acceptance_criteria":"See docs/PLANNING.md eventcore-009 acceptance criteria","status":"open","priority":2,"issue_type":"feature","created_at":"2025-10-22T09:59:54.244346703-07:00","updated_at":"2025-11-02T21:05:05.710968994-08:00","source_repo":".","dependencies":[{"issue_id":"eventcore-009","depends_on_id":"eventcore-008","type":"blocks","created_at":"2025-10-22T09:59:54.254509733-07:00","created_by":"daemon"}]}
{"id":"eventcore-010","content_hash":"e99b46f28ba72ddb4e6564080d87fb3532974c0e3ad772429f7e3730e0046ecc","title":"Chaos Testing Infrastructure","description":"Enable robust testing by injecting failures (read errors, write errors, version conflicts) into in-memory store. Chaos mode for InMemoryEventStore allowing developers to test error handling paths systematically.","design":"**Chaos Configuration**: Configurable failure injection rates, read failures/write failures/version conflict injection, deterministic chaos for reproducible tests\n**Observability**: Consider metrics, tracing, and structured logging for chaos testing (specific requirements determined during implementation)","acceptance_criteria":"See docs/PLANNING.md eventcore-010 acceptance criteria","status":"open","priority":3,"issue_type":"feature","created_at":"2025-10-22T09:59:54.516254533-07:00","updated_at":"2025-11-02T21:05:10.906286157-08:00","source_repo":"."}
{"id":"eventcore-011","content_hash":"cf1bc2703902267de943e9a026af607984ce27322087b8bd8b50d6fda48a6f07","title":"Performance Benchmarking Suite","description":"Establish performance baselines and track regressions using Criterion.rs benchmarks. Comprehensive benchmark suite measuring throughput, latency, and memory usage for key operations.","design":"**Benchmark Suite**: Single-stream command execution, multi-stream command execution, event append throughput, state reconstruction performance, PostgreSQL vs in-memory comparison\n**Criterion.rs**: Reports ops/sec, latency percentiles (P50, P95, P99), results stored for regression tracking\n**Observability**: Consider metrics, tracing, and structured logging for benchmark operations (specific requirements determined during implementation)","acceptance_criteria":"See docs/PLANNING.md eventcore-011 acceptance criteria","status":"open","priority":3,"issue_type":"feature","created_at":"2025-10-22T09:59:54.806895386-07:00","updated_at":"2025-11-02T21:05:16.167260209-08:00","source_repo":".","dependencies":[{"issue_id":"eventcore-011","depends_on_id":"eventcore-004","type":"blocks","created_at":"2025-10-22T09:59:54.818896767-07:00","created_by":"daemon"},{"issue_id":"eventcore-011","depends_on_id":"eventcore-005","type":"blocks","created_at":"2025-10-22T09:59:54.820992753-07:00","created_by":"daemon"}]}
{"id":"eventcore-012","content_hash":"2dc70a8cde8c0fb0e7b6430f66d5e3ccbaf3041cfba60cb635f5fcf208f8f01f","title":"Snapshot Support for Performance","description":"Optimize state reconstruction for long-lived streams by periodically saving snapshots and starting reconstruction from snapshot instead of version 0. Comes AFTER eventcore-011 because we need performance data to determine if snapshots are necessary and what snapshot frequency makes sense.","design":"**SnapshotStore Trait**: save_snapshot(stream_id, version, state) method, load_snapshot(stream_id) returns (version, state), snapshots stored alongside events, automatic snapshot creation at configurable intervals\n**Executor Integration**: Check for snapshot before reading events, if snapshot exists start from snapshot version, apply only events after snapshot\n**Benchmark-Driven**: Use eventcore-011 benchmark data to determine optimal snapshot frequency\n**Observability**: Consider metrics, tracing, and structured logging for snapshot operations (specific requirements determined during implementation)","acceptance_criteria":"See docs/PLANNING.md eventcore-012 acceptance criteria","status":"open","priority":3,"issue_type":"feature","created_at":"2025-10-22T09:59:55.082406342-07:00","updated_at":"2025-11-02T21:05:21.366355197-08:00","source_repo":".","dependencies":[{"issue_id":"eventcore-012","depends_on_id":"eventcore-011","type":"blocks","created_at":"2025-10-22T09:59:55.094589257-07:00","created_by":"daemon"}]}
{"id":"eventcore-013","content_hash":"7d50345575673690962f6bd2fc08969cbc805fd3a56cae197441652831c2bdc4","title":"require! Macro","description":"Provide ergonomic macro for business rule validation with early return, making validation code concise and readable. require! macro that checks conditions and returns CommandError::BusinessRuleViolation on failure. Simpler than emit! (just generates early return with error).","design":"**require! Macro**: Simple condition checking with early return, returns CommandError::BusinessRuleViolation on failure, descriptive error messages from validation expressions, format string support\n**Implementation**: Declarative macro (not proc-macro), expands to if !condition { return Err(...) }, works in any function returning Result\u003c_, CommandError\u003e\n**Observability**: Consider metrics, tracing, and structured logging for business rule violations (specific requirements determined during implementation)","acceptance_criteria":"See docs/PLANNING.md eventcore-013 acceptance criteria","status":"open","priority":2,"issue_type":"feature","created_at":"2025-10-22T09:59:55.382858264-07:00","updated_at":"2025-11-02T21:05:26.624588449-08:00","source_repo":"."}
{"id":"eventcore-014","content_hash":"d0093f073b04b28798651a0e94973d4451c10b150ace7f39ee671af5cf488287","title":"emit! Macro","description":"Provide type-safe event emission macro with compile-time verification that events are emitted to declared streams. emit! macro that works with phantom types from derive macro to provide compile-time safety. More complex than require! - must work with phantom types generated by #[derive(Command)].","design":"**emit! Macro**: Compile-time verification that stream is declared in command, works with phantom types from #[derive(Command)], concise syntax for event emission, IDE autocomplete support\n**Type Safety**: Phantom types ensure events only emitted to declared streams, compile error if emitting to undeclared stream\n**Integration**: Works with phantom types from derive macro, stream names from derive macro available to emit! macro\n**Observability**: Consider metrics, tracing, and structured logging for event emission (specific requirements determined during implementation)","acceptance_criteria":"See docs/PLANNING.md eventcore-014 acceptance criteria","status":"open","priority":2,"issue_type":"feature","created_at":"2025-10-22T09:59:55.698240824-07:00","updated_at":"2025-11-02T21:05:31.826039047-08:00","source_repo":".","dependencies":[{"issue_id":"eventcore-014","depends_on_id":"eventcore-006","type":"blocks","created_at":"2025-10-22T09:59:55.717324222-07:00","created_by":"daemon"}]}
{"id":"eventcore-015","content_hash":"b25c06b33053e97b7e06a624b55598c15b34685e20baac61f44c82991822c9be","title":"Documentation Completeness Audit","description":"Audit and ensure completeness, consistency, and quality of documentation written incrementally throughout eventcore-001 to eventcore-014. NOT 'write all documentation at the end' - each increment includes its own documentation. This ensures documentation is complete, consistent across increments, and ready for library release.","design":"**Completeness Audit**: Verify each increment has Getting Started section, check API docs completeness, ensure examples directory has working code\n**Consistency Audit**: Terminology consistency, code style consistency in examples, accurate cross-references\n**Quality Audit**: Can new developer implement first command in \u003c30 min? Are common issues documented? Are concepts explained for newcomers?","acceptance_criteria":"See docs/PLANNING.md eventcore-015 acceptance criteria","status":"open","priority":2,"issue_type":"chore","created_at":"2025-10-22T09:59:55.9972299-07:00","updated_at":"2025-10-29T14:18:50.669000821-07:00","source_repo":".","dependencies":[{"issue_id":"eventcore-015","depends_on_id":"eventcore-002","type":"blocks","created_at":"2025-10-22T09:59:56.009464365-07:00","created_by":"daemon"},{"issue_id":"eventcore-015","depends_on_id":"eventcore-003","type":"blocks","created_at":"2025-10-22T09:59:56.01170298-07:00","created_by":"daemon"},{"issue_id":"eventcore-015","depends_on_id":"eventcore-004","type":"blocks","created_at":"2025-10-22T09:59:56.013797658-07:00","created_by":"daemon"},{"issue_id":"eventcore-015","depends_on_id":"eventcore-005","type":"blocks","created_at":"2025-10-22T09:59:56.015716896-07:00","created_by":"daemon"},{"issue_id":"eventcore-015","depends_on_id":"eventcore-006","type":"blocks","created_at":"2025-10-22T09:59:56.017720808-07:00","created_by":"daemon"},{"issue_id":"eventcore-015","depends_on_id":"eventcore-007","type":"blocks","created_at":"2025-10-22T09:59:56.019802867-07:00","created_by":"daemon"},{"issue_id":"eventcore-015","depends_on_id":"eventcore-008","type":"blocks","created_at":"2025-10-22T09:59:56.021853841-07:00","created_by":"daemon"},{"issue_id":"eventcore-015","depends_on_id":"eventcore-009","type":"blocks","created_at":"2025-10-22T09:59:56.023919626-07:00","created_by":"daemon"},{"issue_id":"eventcore-015","depends_on_id":"eventcore-010","type":"blocks","created_at":"2025-10-22T09:59:56.025929586-07:00","created_by":"daemon"},{"issue_id":"eventcore-015","depends_on_id":"eventcore-011","type":"blocks","created_at":"2025-10-22T09:59:56.027865114-07:00","created_by":"daemon"},{"issue_id":"eventcore-015","depends_on_id":"eventcore-012","type":"blocks","created_at":"2025-10-22T09:59:56.029888021-07:00","created_by":"daemon"},{"issue_id":"eventcore-015","depends_on_id":"eventcore-013","type":"blocks","created_at":"2025-10-22T09:59:56.031987839-07:00","created_by":"daemon"},{"issue_id":"eventcore-015","depends_on_id":"eventcore-014","type":"blocks","created_at":"2025-10-22T09:59:56.034210146-07:00","created_by":"daemon"}]}
{"id":"eventcore-016","content_hash":"aa1a5465fdac67ee7586b8e835d49a4f0cb05996be18d1b6bfa31ea94e24db02","title":"Error Message Consistency Audit","description":"Audit and ensure consistency, clarity, and actionability of error messages written incrementally throughout eventcore-001 to eventcore-014. NOT 'add error messages at the end' - error quality is foundational from eventcore-001. This ensures error messages are consistent in format, provide appropriate context, and are actionable across all increments.","design":"**Consistency Audit**: Error message format consistency, error type usage consistency, context inclusion patterns, action suggestion patterns\n**Clarity Audit**: Are error messages understandable? Do messages explain WHAT failed and WHY? Are technical terms explained?\n**Actionability Audit**: Does each error suggest next steps? Are links to documentation included? Do validation errors show actual vs expected values?","acceptance_criteria":"See docs/PLANNING.md eventcore-016 acceptance criteria","status":"open","priority":2,"issue_type":"chore","created_at":"2025-10-22T09:59:56.352815929-07:00","updated_at":"2025-10-29T14:18:50.670807718-07:00","source_repo":".","dependencies":[{"issue_id":"eventcore-016","depends_on_id":"eventcore-015","type":"blocks","created_at":"2025-10-22T09:59:56.365070485-07:00","created_by":"daemon"}]}
{"id":"eventcore-1","content_hash":"99b8cc4f23a6ebc9daedc636d2b847d8650bd52effd8dbe39ebefc634849312e","title":"EventStore Contract Test Suite","description":"Provide reusable test suite that EventStore implementors can run against their implementation to verify contract compliance (version conflict detection, basic read/write, etc.) without copy/pasting tests.","design":"**Public Test API**: New `eventcore::testing` module with public test functions\n**Contract Tests**: test_concurrent_version_conflicts, test_basic_read_write, test_stream_isolation\n**Test Domain**: Minimal ContractTestEvent type for generic testing\n**Usage Pattern**: Implementors call test functions with their EventStore instance\n**Documentation**: Clear examples showing how to use in separate crates\n**Optional Enhancement**: Macro-generated test suite for ergonomics","acceptance_criteria":"Feature: EventStore implementor uses contract test suite\n\nScenario 1: Developer tests InMemoryEventStore with contract suite\n- Imports eventcore::testing::event_store_contract_tests\n- Creates InMemoryEventStore instance\n- Calls test_concurrent_version_conflicts(store)\n- Test passes (verifies version conflict detection works)\n- All other contract tests available and documented\n\nScenario 2: Developer discovers their custom EventStore violates contract\n- Implements custom EventStore with naive append (no version checking)\n- Runs test_concurrent_version_conflicts(store)\n- Test FAILS with clear error message\n- Error explains version conflict wasn't detected\n- Developer fixes implementation, test passes\n\nScenario 3: Future PostgreSQL implementor uses contract suite\n- In eventcore-postgres crate tests\n- Imports public test functions\n- Runs full contract suite against PostgreSQL backend\n- All tests pass, contract verified\n- No need to copy/paste or rewrite tests","status":"open","priority":2,"issue_type":"feature","created_at":"2025-10-29T12:30:04.264036084-07:00","updated_at":"2025-10-29T12:30:04.264036084-07:00","source_repo":"."}
{"id":"eventcore-2","content_hash":"5fa53b5f0b187d31b5994a3b034476139b05648691d1900b76c8f860e42d00c1","title":"Single-Stream Command End-to-End","description":"Enable library consumer to create and execute a complete single-stream command with validated domain types, proper error handling, and in-memory event storage. Provides working, testable command execution system.","design":"**Domain Types**: StreamId, EventId, CorrelationId, CausationId (nutype)\n**Error Handling**: Structured hierarchy (EventStoreError, CommandError, ValidationError, ConcurrencyError)\n**Storage**: InMemoryEventStore with optimistic concurrency\n**Command System**: CommandStreams and CommandLogic traits (manual, no macro)\n**Executor**: CommandExecutor orchestrating read → apply → handle → write (NO retry)","acceptance_criteria":"Feature: Developer executes complete single-stream command end-to-end\n\nScenario 1: Developer implements and executes bank account command\n- Creates BankAccount command with StreamId using nutype\n- Implements CommandLogic with apply() and handle()\n- Creates InMemoryEventStore\n- Executes Deposit(account_id, amount: 100)\n- Command succeeds\n- AccountDeposited event is stored with correct metadata\n- Developer can read events from the stream\n- Event contains amount of 100\n\nScenario 2: Developer handles business rule violations with proper errors\n- Account has balance of 50\n- Executes Withdraw command with amount 100\n- CommandError::BusinessRuleViolation is returned\n- Error message explains insufficient funds: balance 50, withdrawal 100\n- Error includes context (account_id, current balance, attempted withdrawal)\n- State is reconstructed via apply() to determine current balance\n\nScenario 3: Developer handles version conflict manually\n- Executes two concurrent Deposit commands on same account\n- Both commands read account at version 0\n- First command writes event, advancing to version 1\n- Second command attempts write expecting version 1\n- ConcurrencyError is returned to developer\n- Developer must handle retry manually (or wait for eventcore-002)\n- No automatic retry occurs\n- Developer can inspect error details (expected vs actual version)","status":"in_progress","priority":1,"issue_type":"feature","assignee":"jwilger","created_at":"2025-10-29T14:18:50.661348377-07:00","updated_at":"2025-10-29T14:18:50.661348377-07:00","source_repo":"."}
