use proc_macro::TokenStream;
use proc_macro2::TokenStream as TokenStream2;
use quote::quote;
use syn::{Data, DeriveInput, Error, Fields, Meta, Path, Type, parse_macro_input};

#[proc_macro_derive(Command, attributes(stream))]
pub fn command(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    match expand_command(&input) {
        Ok(tokens) => tokens.into(),
        Err(error) => error.to_compile_error().into(),
    }
}

fn expand_command(input: &DeriveInput) -> syn::Result<TokenStream2> {
    let ident = &input.ident;

    let data_struct = match &input.data {
        Data::Struct(data_struct) => data_struct,
        _ => {
            return Err(Error::new_spanned(
                ident,
                "EventCore: #[derive(Command)] currently supports structs with named fields",
            ));
        }
    };

    let fields = match &data_struct.fields {
        Fields::Named(fields) => &fields.named,
        _ => {
            return Err(Error::new_spanned(
                ident,
                "EventCore: #[derive(Command)] currently supports structs with named fields",
            ));
        }
    };

    let mut stream_exprs: Vec<TokenStream2> = Vec::new();

    for field in fields {
        let mut has_stream_attribute = false;

        for attr in &field.attrs {
            if attr.path().is_ident("stream") {
                match &attr.meta {
                    Meta::Path(_) => {}
                    _ => {
                        return Err(Error::new_spanned(
                            attr,
                            "EventCore: #[stream] does not accept parameters",
                        ));
                    }
                }

                has_stream_attribute = true;
            }
        }

        if has_stream_attribute {
            let field_ident = match &field.ident {
                Some(ident) => ident,
                None => {
                    return Err(Error::new_spanned(
                        field,
                        "EventCore: #[derive(Command)] currently supports structs with named fields",
                    ));
                }
            };

            match &field.ty {
                Type::Path(type_path) => {
                    if !is_eventcore_stream_id(&type_path.path) {
                        return Err(Error::new_spanned(
                            field,
                            "EventCore: #[stream] fields must have type StreamId",
                        ));
                    }
                }
                _ => {
                    return Err(Error::new_spanned(
                        field,
                        "EventCore: #[stream] fields must have type StreamId",
                    ));
                }
            }

            stream_exprs.push(quote! { self.#field_ident.clone() });
        }
    }

    if stream_exprs.is_empty() {
        return Err(Error::new_spanned(
            ident,
            "EventCore: #[derive(Command)] requires at least one #[stream] StreamId field; add #[stream] to your StreamId member",
        ));
    }

    Ok(quote! {
        impl ::eventcore::CommandStreams for #ident {
            fn stream_declarations(&self) -> ::eventcore::StreamDeclarations {
                ::eventcore::StreamDeclarations::try_from_streams(vec![
                    #( #stream_exprs ),*
                ])
                .expect("valid stream declarations generated by #[derive(Command)]")
            }
        }
    })
}

fn is_eventcore_stream_id(path: &Path) -> bool {
    if path.segments.is_empty() {
        return false;
    }

    if let Some(last) = path.segments.last() {
        if last.ident != "StreamId" {
            return false;
        }
    } else {
        return false;
    }

    path.segments
        .iter()
        .take(path.segments.len().saturating_sub(1))
        .all(|segment| {
            matches!(
                segment.ident.to_string().as_str(),
                "eventcore" | "crate" | "self" | "super"
            )
        })
}
