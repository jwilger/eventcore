use proc_macro::TokenStream;
use quote::quote;
use syn::{Data, Fields, parse_macro_input};

#[proc_macro_derive(Command, attributes(stream))]
pub fn command(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as syn::DeriveInput);

    let ident = input.ident;

    let stream_field_idents = match &input.data {
        Data::Struct(data_struct) => match &data_struct.fields {
            Fields::Named(fields) => fields
                .named
                .iter()
                .filter(|field| {
                    field
                        .attrs
                        .iter()
                        .any(|attr| attr.path().is_ident("stream"))
                })
                .map(|field| field.ident.clone().expect("expected named field"))
                .collect::<Vec<_>>(),
            _ => panic!("expected struct with named fields"),
        },
        _ => panic!("expected named struct for #[derive(Command)]"),
    };

    if stream_field_idents.is_empty() {
        panic!("expected at least one #[stream] field for #[derive(Command)]");
    }

    let stream_exprs = stream_field_idents
        .iter()
        .map(|ident| quote! { self.#ident.clone() });

    TokenStream::from(quote! {
        impl ::eventcore::CommandStreams for #ident {
            fn stream_declarations(&self) -> ::eventcore::StreamDeclarations {
                ::eventcore::StreamDeclarations::try_from_streams(vec![
                    #( #stream_exprs ),*
                ])
                .expect("valid stream declarations generated by #[derive(Command)]")
            }
        }
    })
}
