use proc_macro::TokenStream;
use quote::quote;
use syn::{
    Data, DeriveInput, Error, Fields, Index, Meta, Result, Type, parse_macro_input,
    spanned::Spanned,
};

#[proc_macro_derive(Command, attributes(stream))]
pub fn command(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    match expand_command(input) {
        Ok(tokens) => tokens.into(),
        Err(error) => error.to_compile_error().into(),
    }
}

fn expand_command(input: DeriveInput) -> Result<proc_macro2::TokenStream> {
    let ident = input.ident;
    let generics = input.generics;
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    let Data::Struct(data_struct) = input.data else {
        return Err(Error::new_spanned(
            &ident,
            "EventCore: #[derive(Command)] currently supports struct types only",
        ));
    };

    let mut stream_field_exprs = Vec::new();

    match data_struct.fields {
        Fields::Named(ref fields) => {
            for field in &fields.named {
                if let Some(expr) = stream_field_expression(field)? {
                    stream_field_exprs.push(expr);
                }
            }
        }
        Fields::Unnamed(ref fields) => {
            for (position, field) in fields.unnamed.iter().enumerate() {
                if let Some(expr) = stream_tuple_field_expression(field, position)? {
                    stream_field_exprs.push(expr);
                }
            }
        }
        Fields::Unit => {
            return Err(Error::new(
                ident.span(),
                "EventCore: #[derive(Command)] requires at least one #[stream] field",
            ));
        }
    }

    if stream_field_exprs.is_empty() {
        return Err(Error::new(
            ident.span(),
            "EventCore: #[derive(Command)] requires at least one field annotated with #[stream]",
        ));
    }

    Ok(quote! {
        impl #impl_generics ::eventcore::CommandStreams for #ident #ty_generics #where_clause {
            fn stream_declarations(&self) -> ::eventcore::StreamDeclarations {
                ::eventcore::StreamDeclarations::try_from_streams(vec![
                    #( #stream_field_exprs ),*
                ])
                .expect("valid stream declarations generated by #[derive(Command)]")
            }
        }
    })
}

fn stream_field_expression(field: &syn::Field) -> Result<Option<proc_macro2::TokenStream>> {
    if !has_stream_attribute(field)? {
        return Ok(None);
    }

    ensure_stream_id_type(field)?;

    let Some(ident) = &field.ident else {
        return Err(Error::new(
            field.span(),
            "EventCore: #[derive(Command)] encountered an unnamed field where a named field was expected",
        ));
    };

    let expr = quote! { self.#ident.clone() };
    Ok(Some(expr))
}

fn stream_tuple_field_expression(
    field: &syn::Field,
    position: usize,
) -> Result<Option<proc_macro2::TokenStream>> {
    if !has_stream_attribute(field)? {
        return Ok(None);
    }

    ensure_stream_id_type(field)?;

    let index = Index::from(position);
    let expr = quote! { self.#index.clone() };
    Ok(Some(expr))
}

fn has_stream_attribute(field: &syn::Field) -> Result<bool> {
    let mut found = false;
    for attr in &field.attrs {
        if !attr.path().is_ident("stream") {
            continue;
        }

        match &attr.meta {
            Meta::Path(_) => {
                found = true;
            }
            _ => {
                return Err(Error::new_spanned(
                    attr,
                    "EventCore: #[stream] does not accept parameters",
                ));
            }
        }
    }
    Ok(found)
}

fn ensure_stream_id_type(field: &syn::Field) -> Result<()> {
    if matches!(
        &field.ty,
        Type::Path(type_path)
            if type_path.qself.is_none()
                && type_path
                    .path
                    .segments
                    .last()
                    .map(|segment| segment.ident == "StreamId")
                    .unwrap_or(false)
    ) {
        return Ok(());
    }

    Err(Error::new_spanned(
        field,
        "EventCore: #[stream] fields must have type StreamId",
    ))
}
