#![forbid(
    dead_code,
    invalid_value,
    overflowing_literals,
    unconditional_recursion,
    unreachable_pub,
    unused_allocation,
    unsafe_code
)]
#![deny(
    bad_style,
    clippy::allow_attributes,
    deprecated,
    meta_variable_misuse,
    non_ascii_idents,
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    rust_2018_idioms,
    rust_2021_compatibility,
    trivial_casts,
    trivial_numeric_casts,
    unreachable_code,
    unused_assignments,
    unused_attributes,
    unused_extern_crates,
    unused_imports,
    unused_must_use,
    unused_mut,
    unused_parens,
    unused_qualifications,
    unused_results,
    unused_variables
)]

use proc_macro::TokenStream;
use proc_macro2::TokenStream as TokenStream2;
use quote::quote;
use syn::{
    Data, DeriveInput, Error, Field, Fields, Meta, Path, Type, parse_macro_input,
    punctuated::Punctuated,
};

/// Macro entry point that generates `CommandStreams` implementations for
/// structs whose `StreamId` fields are annotated with `#[stream]`.
#[proc_macro_derive(Command, attributes(stream))]
pub fn command(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    match expand_command(&input) {
        Ok(tokens) => tokens.into(),
        Err(error) => error.to_compile_error().into(),
    }
}

/// Macro entry point that generates `Event` implementations for
/// structs whose `StreamId` fields are annotated with `#[stream]`.
#[proc_macro_derive(Event, attributes(stream))]
pub fn event(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    match expand_event(&input) {
        Ok(tokens) => tokens.into(),
        Err(error) => error.to_compile_error().into(),
    }
}

fn expand_command(input: &DeriveInput) -> syn::Result<TokenStream2> {
    let ident = &input.ident;
    let fields = extract_named_fields(input)?;
    let stream_exprs = collect_stream_fields(fields)?;

    if stream_exprs.is_empty() {
        return Err(Error::new_spanned(
            ident,
            "EventCore: #[derive(Command)] requires at least one #[stream] StreamId field; add #[stream] to your StreamId member",
        ));
    }

    Ok(quote! {
        impl ::eventcore::CommandStreams for #ident {
            fn stream_declarations(&self) -> ::eventcore::StreamDeclarations {
                ::eventcore::StreamDeclarations::try_from_streams(vec![
                    #( #stream_exprs ),*
                ])
                .expect("valid stream declarations generated by #[derive(Command)]")
            }
        }
    })
}

fn expand_event(input: &DeriveInput) -> syn::Result<TokenStream2> {
    let ident = &input.ident;

    match &input.data {
        Data::Struct(_) => expand_event_struct(input, ident),
        Data::Enum(data_enum) => expand_event_enum(input, ident, data_enum),
        _ => Err(Error::new_spanned(
            ident,
            "EventCore: #[derive(Event)] only supports structs and enums",
        )),
    }
}

fn expand_event_struct(input: &DeriveInput, ident: &syn::Ident) -> syn::Result<TokenStream2> {
    let fields = extract_named_fields(input)?;
    let stream_field = find_stream_field(fields)?;
    let type_name = ident.to_string();

    Ok(quote! {
        impl ::eventcore::Event for #ident {
            fn stream_id(&self) -> &::eventcore::StreamId {
                &self.#stream_field
            }

            fn event_type_name(&self) -> ::eventcore::EventTypeName {
                #type_name.try_into().expect("valid event type name")
            }

            fn all_type_names() -> Vec<::eventcore::EventTypeName> {
                vec![#type_name.try_into().expect("valid event type name")]
            }
        }
    })
}

fn expand_event_enum(
    _input: &DeriveInput,
    ident: &syn::Ident,
    data_enum: &syn::DataEnum,
) -> syn::Result<TokenStream2> {
    let mut stream_id_arms = Vec::new();
    let mut event_type_arms = Vec::new();
    let mut all_type_names = Vec::new();

    for variant in &data_enum.variants {
        let variant_ident = &variant.ident;
        let variant_name = variant_ident.to_string();

        let Fields::Named(fields) = &variant.fields else {
            return Err(Error::new_spanned(
                variant,
                "EventCore: #[derive(Event)] only supports enum variants with named fields",
            ));
        };

        let stream_field = find_stream_field(&fields.named)?;

        stream_id_arms.push(quote! {
            #ident::#variant_ident { #stream_field, .. } => #stream_field
        });

        event_type_arms.push(quote! {
            #ident::#variant_ident { .. } => #variant_name.try_into().expect("valid event type name")
        });

        all_type_names.push(quote! {
            #variant_name.try_into().expect("valid event type name")
        });
    }

    Ok(quote! {
        impl ::eventcore::Event for #ident {
            fn stream_id(&self) -> &::eventcore::StreamId {
                match self {
                    #( #stream_id_arms ),*
                }
            }

            fn event_type_name(&self) -> ::eventcore::EventTypeName {
                match self {
                    #( #event_type_arms ),*
                }
            }

            fn all_type_names() -> Vec<::eventcore::EventTypeName> {
                vec![#( #all_type_names ),*]
            }
        }
    })
}

/// Ensures the derive target is a struct with named fields and returns them for
/// further validation.
fn extract_named_fields(input: &DeriveInput) -> syn::Result<&Punctuated<Field, syn::token::Comma>> {
    let Data::Struct(data_struct) = &input.data else {
        return Err(Error::new_spanned(
            &input.ident,
            "EventCore: #[derive(Command)] only supports structs with named fields",
        ));
    };

    let Fields::Named(fields) = &data_struct.fields else {
        return Err(Error::new_spanned(
            &input.ident,
            "EventCore: #[derive(Command)] only supports structs with named fields",
        ));
    };

    Ok(&fields.named)
}

/// Walks the struct fields, validating #[stream] usages and producing the
/// expressions used in the generated CommandStreams impl.
fn collect_stream_fields(
    fields: &Punctuated<Field, syn::token::Comma>,
) -> syn::Result<Vec<TokenStream2>> {
    let mut stream_exprs = Vec::new();

    for field in fields {
        if has_stream_marker(field)? {
            stream_exprs.push(stream_expression(field)?);
        }
    }

    Ok(stream_exprs)
}

/// Returns true when the field carries a valid #[stream] attribute.
fn has_stream_marker(field: &Field) -> syn::Result<bool> {
    let mut marked = false;

    for attr in &field.attrs {
        if attr.path().is_ident("stream") {
            if !matches!(&attr.meta, Meta::Path(_)) {
                return Err(Error::new_spanned(
                    attr,
                    "EventCore: #[stream] does not accept parameters",
                ));
            }

            marked = true;
        }
    }

    Ok(marked)
}

/// Produces the `self.field.clone()` expression for a validated stream field.
fn stream_expression(field: &Field) -> syn::Result<TokenStream2> {
    let Some(field_ident) = &field.ident else {
        return Err(Error::new_spanned(
            field,
            "EventCore: #[derive(Command)] only supports structs with named fields",
        ));
    };

    ensure_stream_id_type(field)?;

    Ok(quote! { self.#field_ident.clone() })
}

/// Confirms the field type resolves to StreamId (allowing qualified paths).
fn ensure_stream_id_type(field: &Field) -> syn::Result<()> {
    match &field.ty {
        Type::Path(type_path) if is_eventcore_stream_id(&type_path.path) => Ok(()),
        _ => Err(Error::new_spanned(
            field,
            "EventCore: #[stream] fields must have type eventcore::StreamId",
        )),
    }
}

fn is_eventcore_stream_id(path: &Path) -> bool {
    let Some(last) = path.segments.last() else {
        return false;
    };

    if last.ident != "StreamId" {
        return false;
    }

    path.segments
        .iter()
        .take(path.segments.len().saturating_sub(1))
        .all(|segment| {
            matches!(
                segment.ident.to_string().as_str(),
                "eventcore" | "crate" | "self" | "super"
            )
        })
}

/// Finds the single field marked with #[stream] and returns its identifier.
fn find_stream_field(fields: &Punctuated<Field, syn::token::Comma>) -> syn::Result<syn::Ident> {
    let mut stream_field = None;

    for field in fields {
        if has_stream_marker(field)? {
            let Some(field_ident) = &field.ident else {
                return Err(Error::new_spanned(
                    field,
                    "EventCore: #[derive(Event)] only supports structs with named fields",
                ));
            };

            ensure_stream_id_type(field)?;

            if stream_field.is_some() {
                return Err(Error::new_spanned(
                    field,
                    "EventCore: #[derive(Event)] only supports one #[stream] field",
                ));
            }

            stream_field = Some(field_ident.clone());
        }
    }

    stream_field.ok_or_else(|| {
        Error::new_spanned(
            fields,
            "EventCore: #[derive(Event)] requires at least one #[stream] StreamId field; add #[stream] to your StreamId member",
        )
    })
}
