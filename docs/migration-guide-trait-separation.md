# Migration Guide: Command Trait Separation

This guide helps you migrate existing EventCore commands to use the new simplified trait separation pattern introduced in version 0.2.

## Overview

The `Command` trait has been split into two traits to reduce boilerplate and improve separation of concerns:

- `CommandStreams`: Handles stream declaration and input types (can be auto-generated)
- `CommandLogic`: Contains your domain logic (manually implemented)
- `Command`: Now simply extends both traits for backward compatibility

## Benefits

- **50% less boilerplate**: No need to manually specify `type Input = Self` or `type StreamSet = ...`
- **Cleaner separation**: Infrastructure concerns (streams) separated from domain logic
- **Better macro support**: The derive macro generates complete trait implementations
- **Backward compatible**: Existing code continues to work unchanged

## Migration Options

### Option 1: Keep Existing Code (No Changes Required)

Your existing commands that directly implement `Command` will continue to work without any changes:

```rust
// This still works perfectly fine
#[async_trait]
impl Command for MyCommand {
    type Input = MyInput;
    type State = MyState;
    type Event = MyEvent;
    type StreamSet = ();
    
    fn read_streams(&self, input: &Self::Input) -> Vec<StreamId> {
        // ...
    }
    
    fn apply(&self, state: &mut Self::State, event: &StoredEvent<Self::Event>) {
        // ...
    }
    
    async fn handle(...) -> CommandResult<Vec<StreamWrite<Self::StreamSet, Self::Event>>> {
        // ...
    }
}
```

### Option 2: Migrate to Simplified Pattern (Recommended)

For new commands or when refactoring, use the simplified pattern with `#[derive(Command)]`:

#### Before (Manual Implementation)

```rust
use eventcore::{Command, CommandResult, ReadStreams, StreamWrite};
use async_trait::async_trait;

#[derive(Clone)]
struct TransferMoney {
    from_account: StreamId,
    to_account: StreamId,
    amount: Money,
}

// Manually define StreamSet phantom type
struct TransferMoneyStreamSet;

#[async_trait]
impl Command for TransferMoney {
    type Input = Self;                          // Manual boilerplate
    type StreamSet = TransferMoneyStreamSet;    // Manual boilerplate
    type State = AccountBalances;
    type Event = BankingEvent;
    
    fn read_streams(&self, input: &Self::Input) -> Vec<StreamId> {  // Manual boilerplate
        vec![input.from_account.clone(), input.to_account.clone()]
    }
    
    fn apply(&self, state: &mut Self::State, event: &StoredEvent<Self::Event>) {
        // Your domain logic
    }
    
    async fn handle(...) -> CommandResult<Vec<StreamWrite<Self::StreamSet, Self::Event>>> {
        // Your business logic
    }
}
```

#### After (Simplified with Derive Macro)

```rust
use eventcore_macros::Command;
use eventcore::{CommandLogic, prelude::*};
use async_trait::async_trait;

#[derive(Command, Clone)]
struct TransferMoney {
    #[stream]
    from_account: StreamId,
    #[stream] 
    to_account: StreamId,
    amount: Money,
}

// The derive macro automatically generates:
// - impl CommandStreams with type Input = Self
// - type StreamSet = TransferMoneyStreamSet
// - fn read_streams() implementation

#[async_trait]
impl CommandLogic for TransferMoney {
    type State = AccountBalances;    // Only domain-specific types
    type Event = BankingEvent;       // Only domain-specific types
    
    fn apply(&self, state: &mut Self::State, event: &StoredEvent<Self::Event>) {
        // Your domain logic (unchanged)
    }
    
    async fn handle(
        &self,
        read_streams: ReadStreams<Self::StreamSet>,
        state: Self::State,
        input: Self::Input,
        stream_resolver: &mut StreamResolver,
    ) -> CommandResult<Vec<StreamWrite<Self::StreamSet, Self::Event>>> {
        // Your business logic (unchanged)
    }
}
```

## Step-by-Step Migration

1. **Add the derive macro** to your command struct:
   ```rust
   #[derive(Command, Clone)]  // Add Command derive
   struct MyCommand {
       // ...
   }
   ```

2. **Mark stream fields** with `#[stream]`:
   ```rust
   #[derive(Command, Clone)]
   struct MyCommand {
       #[stream]
       account_id: StreamId,
       #[stream]
       other_stream: StreamId,
       // Non-stream fields don't need annotation
       amount: Money,
   }
   ```

3. **Change trait from Command to CommandLogic**:
   ```rust
   // Before
   impl Command for MyCommand {
   
   // After
   impl CommandLogic for MyCommand {
   ```

4. **Remove boilerplate types**:
   ```rust
   // Remove these lines:
   // type Input = Self;
   // type StreamSet = MyCommandStreamSet;
   ```

5. **Remove read_streams method**:
   ```rust
   // Delete this entire method - it's generated by the macro
   // fn read_streams(&self, input: &Self::Input) -> Vec<StreamId> {
   //     vec![...]
   // }
   ```

6. **Update imports**:
   ```rust
   use eventcore::{CommandLogic, prelude::*};
   use eventcore_macros::Command;
   ```

## Common Patterns

### Commands with Complex Input Types

If your command uses a separate input type (not `Self`), you'll need to continue using manual implementation:

```rust
// Manual implementation still required for complex input types
struct MyCommand;

#[async_trait]
impl Command for MyCommand {
    type Input = ComplexInput;  // Not Self, so can't use derive
    // ... rest of implementation
}
```

### Commands with No Streams

The macro works perfectly for commands that don't access any streams:

```rust
#[derive(Command, Clone)]
struct GlobalCommand {
    // No #[stream] fields
    setting: String,
}

#[async_trait]
impl CommandLogic for GlobalCommand {
    // ... implementation
}
```

## Troubleshooting

### Error: "cannot find trait `CommandLogic` in this scope"

Add the import:
```rust
use eventcore::CommandLogic;
```

### Error: "the trait bound `MyCommand: CommandStreams` is not satisfied"

Make sure you've added `#[derive(Command)]` to your struct.

### Error: "cannot find attribute `stream` in this scope"

The `#[stream]` attribute comes from the derive macro. Ensure you have:
```rust
use eventcore_macros::Command;
#[derive(Command)]
```

## Best Practices

1. **Use the derive macro for new commands** - It reduces boilerplate and prevents errors
2. **Keep domain logic in CommandLogic** - This separates infrastructure from business logic
3. **Don't migrate working code immediately** - The old pattern still works fine
4. **Test after migration** - Ensure your commands behave identically after migration

## Example: Complete Migration

See `eventcore-examples/src/simplified_command_example.rs` for a complete working example showing both the old and new patterns side by side.

## Questions?

The trait separation is designed to be intuitive:
- `CommandStreams` = "What streams does this command access?"
- `CommandLogic` = "What does this command do?"

If you have questions or run into issues, please open an issue on GitHub.