# Enhanced Command Derive Macro

The `#[derive(Command)]` macro has been enhanced to significantly reduce boilerplate when implementing EventCore commands through a new trait separation approach.

## Overview

The Command trait has been split into two traits:
- **CommandStreams**: Handles stream declaration and input types (auto-generated by the macro)
- **CommandLogic**: Contains your domain logic (manually implemented)

This separation reduces boilerplate by ~50% while maintaining full backward compatibility.

## Migration Guide

For detailed migration instructions, see [migration-guide-trait-separation.md](./migration-guide-trait-separation.md).

## Before and After

### Before (Manual Implementation)

```rust
#[derive(Command)]
struct TransferMoney {
    #[stream]
    from_account: StreamId,
    #[stream]
    to_account: StreamId,
    amount: Money,
}

#[async_trait]
impl Command for TransferMoney {
    type Input = Self;                        // ❌ Manual boilerplate
    type StreamSet = TransferMoneyStreamSet;  // ❌ Manual boilerplate
    type State = AccountBalances;
    type Event = BankingEvent;

    fn read_streams(&self, input: &Self::Input) -> Vec<StreamId> {  // ❌ Manual implementation
        vec![input.from_account.clone(), input.to_account.clone()]
    }

    fn apply(&self, state: &mut Self::State, event: &StoredEvent<Self::Event>) {
        // Domain logic...
    }

    async fn handle(...) -> CommandResult<...> {
        // Domain logic...
    }
}
```

### After (Enhanced Macro with Trait Separation)

```rust
#[derive(Command, Clone)]
struct TransferMoney {
    #[stream]
    from_account: StreamId,
    #[stream]
    to_account: StreamId,
    amount: Money,
}

// The derive macro automatically generates:
// - impl CommandStreams with type Input = Self
// - type StreamSet = TransferMoneyStreamSet  
// - fn read_streams() implementation

#[async_trait]
impl CommandLogic for TransferMoney {
    type State = AccountBalances;             // Only domain-specific types
    type Event = BankingEvent;                // Only domain-specific types

    fn apply(&self, state: &mut Self::State, event: &StoredEvent<Self::Event>) {
        // Domain logic...
    }

    async fn handle(...) -> CommandResult<...> {
        // Domain logic...
    }
}
```

## What the Macro Generates

The `#[derive(Command)]` macro automatically generates:

1. **StreamSet Type**: A phantom type for compile-time stream access control
   ```rust
   #[derive(Debug, Clone, Copy, Default)]
   pub struct TransferMoneyStreamSet;
   ```

2. **Complete CommandStreams Implementation**:
   ```rust
   impl CommandStreams for TransferMoney {
       type Input = Self;
       type StreamSet = TransferMoneyStreamSet;
       
       fn read_streams(&self, _input: &Self::Input) -> Vec<StreamId> {
           vec![self.from_account.clone(), self.to_account.clone()]
       }
   }
   ```

## Benefits

### Reduced Boilerplate
- **50% less code**: Eliminates manual stream extraction and type declarations
- **Automatic updates**: Changes to `#[stream]` fields automatically update generated code
- **Type safety**: Compile-time guarantees about stream access

### Consistency
- **Standardized patterns**: All commands follow the same stream extraction pattern
- **Error prevention**: Eliminates manual mistakes in stream extraction logic
- **Maintainability**: Generated code is always correct and up-to-date

### Developer Experience
- **Less cognitive load**: Focus on domain logic instead of boilerplate
- **Faster development**: Quicker to implement new commands
- **Clear separation**: Generated vs. domain-specific code is clearly delineated

## Usage Patterns

### Simple Commands (Input = Self)

When the command struct itself serves as the input (the most common pattern):

```rust
#[derive(Command, Clone)]  // Clone needed for Input = Self
struct CreateOrder {
    #[stream] customer_stream: StreamId,
    #[stream] inventory_stream: StreamId,
    order_data: OrderData,
}

// The macro generates CommandStreams implementation with:
// - type Input = Self
// - type StreamSet = CreateOrderStreamSet
// - fn read_streams() implementation

#[async_trait]
impl CommandLogic for CreateOrder {
    type State = OrderState;
    type Event = OrderEvent;
    // ... only domain logic implementation
}
```

### Commands with Separate Input Types

For commands that need a separate input type, you'll need to use manual implementation:

```rust
struct ProcessPayment;

struct ProcessPaymentInput {
    payment_id: PaymentId,
    account_id: AccountId,
    amount: Money,
}

// Manual implementation required for non-Self input types
#[async_trait]
impl Command for ProcessPayment {
    type Input = ProcessPaymentInput;      // Custom input type
    type StreamSet = ();                   // Phantom type
    type State = PaymentState;
    type Event = PaymentEvent;
    
    fn read_streams(&self, input: &Self::Input) -> Vec<StreamId> {
        vec![
            StreamId::try_new(format!("payment-{}", input.payment_id)).unwrap(),
            StreamId::try_new(format!("account-{}", input.account_id)).unwrap(),
        ]
    }
    // ... rest of implementation
}
```

> **Note**: The derive macro currently only supports `type Input = Self`. For commands with separate input types, continue using the manual implementation approach.

## Quick Migration Steps

1. **Add the derive macro**:
   ```rust
   #[derive(Command, Clone)]
   struct YourCommand { ... }
   ```

2. **Mark stream fields**:
   ```rust
   #[stream]
   account_id: StreamId,
   ```

3. **Change trait to CommandLogic**:
   ```rust
   // Before: impl Command for YourCommand
   // After:  impl CommandLogic for YourCommand
   ```

4. **Remove boilerplate** (these are now generated):
   - `type Input = Self;`
   - `type StreamSet = YourCommandStreamSet;`
   - `fn read_streams() { ... }`

For detailed migration instructions, see [migration-guide-trait-separation.md](./migration-guide-trait-separation.md).

### Backward Compatibility

The enhanced macro maintains **100% backward compatibility**:
- Existing manual Command implementations continue to work
- No breaking changes to the Command trait
- Migration is optional and can be done gradually

## Best Practices

### When to Use Input = Self
- ✅ Simple commands where the struct contains all necessary data
- ✅ Commands that don't need input validation beyond type construction
- ✅ Commands where input is immutable throughout execution

### When to Use Separate Input Types
- ✅ Commands requiring complex input validation
- ✅ Commands where input needs transformation before processing
- ✅ Commands used in APIs where input format differs from internal structure

### Naming Conventions
- Stream fields should be descriptive: `customer_stream`, `product_stream`
- Command names should be imperative: `CreateOrder`, `ProcessPayment`
- Generated StreamSet follows pattern: `{CommandName}StreamSet`

## Examples

See the [simplified command example](../eventcore-examples/src/simplified_command_example.rs) for a complete working demonstration of the enhanced macro.

## Technical Details

### Generated Code Location
- StreamSet types are generated in the same module as the command
- Helper methods are implemented on the command struct itself
- All generated items are `pub` for maximum flexibility

### Compile-Time Guarantees
- Stream access is verified at compile time
- Type safety is maintained through phantom types
- Generated code follows Rust's safety and ownership principles

### Performance Impact
- **Zero runtime cost**: All generated code is compile-time
- **Identical performance**: Generated code matches hand-written equivalents
- **Memory efficient**: Phantom types have zero size overhead