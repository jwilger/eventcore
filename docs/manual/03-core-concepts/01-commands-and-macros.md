# Chapter 3.1: Commands and the Macro System

This chapter explores how EventCore's command system works, focusing on the `#[derive(Command)]` macro that eliminates boilerplate while maintaining type safety.

## The Command Pattern

Commands in EventCore represent user intentions - things that should happen in your system. They:

1. **Declare required streams** - What data they need access to
2. **Validate business rules** - Ensure operations are allowed
3. **Generate events** - Record what actually happened
4. **Maintain consistency** - All changes are atomic

## Anatomy of a Command

Let's dissect a command to understand each part:

```rust
#[derive(Command, Clone)]         // 1. Derive macro generates boilerplate
struct TransferMoney {
    #[stream]                     // 2. Declares this field is a stream
    from_account: StreamId,

    #[stream]
    to_account: StreamId,

    amount: Money,                // 3. Regular fields for command data
    reference: String,
}
```

### What the Macro Generates

The `#[derive(Command)]` macro generates several things:

```rust
// Implementation of CommandStreams generated by the macro
impl CommandStreams for TransferMoney {
    fn stream_declarations(&self) -> StreamDeclarations {
        StreamDeclarations::try_from_streams(vec![
            self.from_account.clone(),
            self.to_account.clone(),
        ])
        .expect("valid stream declarations")
    }
}

// Blanket implementation gives you CommandLogic
// (because TransferMoney also implements CommandLogic)
```

## The Two-Trait Design

EventCore splits the Command pattern into two traits:

### CommandStreams (Generated)

Handles infrastructure concerns:

```rust
pub trait CommandStreams {
    /// Returns the declared streams for this command.
    fn stream_declarations(&self) -> StreamDeclarations;
}
```

### CommandLogic (You Implement)

Contains your domain logic:

```rust
pub trait CommandLogic: CommandStreams {
    /// State type reconstructed from events
    type State: Default;

    /// Event type this command produces
    type Event: Event;

    /// Apply an event to update state (event sourcing fold)
    fn apply(&self, state: Self::State, event: &Self::Event) -> Self::State;

    /// Business logic that validates and produces events
    fn handle(&self, state: Self::State) -> Result<NewEvents<Self::Event>, CommandError>;
}
```

## Stream Declaration Patterns

### Basic Stream Declaration

```rust
#[derive(Command, Clone)]
struct UpdateProfile {
    #[stream]
    user_id: StreamId,  // Single stream
}
```

### Multiple Streams

```rust
#[derive(Command, Clone)]
struct ProcessOrder {
    #[stream]
    order_id: StreamId,

    #[stream]
    customer_id: StreamId,

    #[stream]
    inventory_id: StreamId,

    #[stream]
    payment_id: StreamId,
}
```

### Stream Arrays (Planned Feature)

```rust
#[derive(Command, Clone)]
struct BulkUpdate {
    #[stream("items")]
    item_ids: Vec<StreamId>,  // Multiple streams of same type
}
```

### Conditional Streams

Commands declare their required streams via `stream_declarations()`. The executor may perform dynamic discovery as a separate phase (see StreamResolver in ADR-014, which supersedes ADR-009) but your `handle` implementation focuses on domain logic and does not mutate infrastructure helpers. A typical `handle` implementation returns the events that should be emitted:

```rust
fn handle(&self, state: Self::State) -> Result<NewEvents<Self::Event>, CommandError> {
    // If business logic determines additional side-effects, return events accordingly.
    if state.requires_approval {
        let approval_requested = BankEvent::ApprovalRequested {
            account_id: self.from_account.clone(),
            reference: self.reference.clone(),
        };

        return Ok(NewEvents::from(vec![approval_requested]));
    }

    // No events to emit
    Ok(NewEvents::from(vec![]))
}
```

## Choosing Static, Dynamic, or Hybrid Strategies

| Scenario                                                                        | Recommendation                                                                                                                                                                                                                                                                                         |
| ------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Streams are known at design time and every command instance needs the same set  | Declare them statically with `#[stream]` – simplest and fastest.                                                                                                                                                                                                                                       |
| Streams depend on runtime data (e.g., order references a payment method stream) | Implement `StreamResolver<State>` and override `CommandLogic::stream_resolver()` to return `Some(self)`. Return additional `StreamId` values from `discover_related_streams(&state)`; the executor queues each new ID exactly once and folds its events into the same state before calling `handle()`. |
| Some streams are always required but others are state-dependent                 | Use a hybrid: keep the guaranteed streams in `#[stream]` fields and return optional ones from the resolver. All streams (static + discovered) participate in the same optimistic concurrency check, so emitting events to a discovered stream is as safe as writing to a declared one.                 |

**Guidance:** Prefer static declarations when possible. Reach for StreamResolver when state truly dictates stream boundaries (payment methods, per-item inventory, tenant shards, etc.). Combining both keeps compile-time guarantees for the known streams without sacrificing flexibility for state-dependent relationships.

## Type-Safe Stream Access

Command authors produce domain events; the executor maps those events to their streams using each event's `stream_id()` implementation and ensures writes only target declared streams. Example `handle` returning a domain event:

```rust
fn handle(&self, state: Self::State) -> Result<NewEvents<Self::Event>, CommandError> {
    require!(state.balance >= self.amount, "Insufficient funds");

    let withdraw_event = BankEvent::MoneyWithdrawn {
        account_id: self.from_account.clone(),
        amount: self.amount,
    };

    // Return events - executor will map them to streams based on event.stream_id()
    Ok(NewEvents::from(vec![withdraw_event]))
}
```

Attempting to persist an event for a stream not declared by `stream_declarations()` will be detected and rejected by the executor during the atomic write phase; command authors only return events and do not directly construct storage-level writes.

## State Reconstruction

The `apply` method builds state by folding events:

```rust
fn apply(&self, state: &mut Self::State, event: &StoredEvent<Self::Event>) {
    match &event.payload {
        BankEvent::AccountOpened { balance, .. } => {
            state.exists = true;
            state.balance = *balance;
        }
        BankEvent::MoneyDeposited { amount, .. } => {
            state.balance += amount;
        }
        BankEvent::MoneyWithdrawn { amount, .. } => {
            state.balance = state.balance.saturating_sub(*amount);
        }
    }
}
```

This is called for each event in sequence to rebuild current state.

## Command Validation Patterns

### Using the `require!` Macro

```rust
fn handle(&self, state: Self::State) -> Result<NewEvents<Self::Event>, CommandError> {
    // Business rule validation with good error messages
    require!(
        state.balance >= self.amount,
        "Insufficient funds: balance={}, requested={}",
        state.balance,
        self.amount
    );

    require!(
        self.amount > 0,
        "Transfer amount must be positive"
    );

    require!(
        self.from_account != self.to_account,
        "Cannot transfer to same account"
    );

    // Generate events after validation passes
    let deposited = BankEvent::MoneyDeposited {
        account_id: self.to_account.clone(),
        amount: self.amount,
    };

    let withdrawn = BankEvent::MoneyWithdrawn {
        account_id: self.from_account.clone(),
        amount: self.amount,
    };

    Ok(NewEvents::from(vec![withdrawn, deposited]))
}
```

### Custom Validation Functions

```rust
impl TransferMoney {
    fn validate_transfer_limits(&self, state: &AccountState) -> Result<(), CommandError> {
        const DAILY_LIMIT: u64 = 10_000;

        let daily_total = state.transfers_today + self.amount;
        require!(
            daily_total <= DAILY_LIMIT,
            "Daily transfer limit exceeded: {} > {}",
            daily_total,
            DAILY_LIMIT
        );

        Ok(())
    }
}
```

## Advanced Macro Features

### Custom Stream Names

```rust
#[derive(Command, Clone)]
struct ComplexCommand {
    #[stream(name = "primary")]
    main_stream: StreamId,

    #[stream(name = "secondary", optional = true)]
    optional_stream: Option<StreamId>,
}
```

### Computed Streams

```rust
impl ComplexCommand {
    fn compute_streams(&self) -> Vec<StreamId> {
        let mut streams = vec![self.main_stream.clone()];

        if let Some(ref optional) = self.optional_stream {
            streams.push(optional.clone());
        }

        streams
    }
}
```

## Command Composition

Commands can be composed for complex operations:

```rust
#[derive(Command, Clone)]
struct CompleteOrderWorkflow {
    #[stream]
    order_id: StreamId,

    // Sub-commands to execute
    payment: ProcessPayment,
    fulfillment: FulfillOrder,
    notification: SendNotification,
}

impl CommandLogic for CompleteOrderWorkflow {
    // ... implementation delegates to sub-commands
}
```

## Performance Optimizations

### Pre-computed State

For expensive computations:

```rust
#[derive(Default)]
struct PrecomputedState {
    balance: u64,
    transaction_count: u64,
    daily_totals: HashMap<Date, u64>,  // Pre-aggregated
}

fn apply(&self, state: &mut Self::State, event: &StoredEvent<Self::Event>) {
    // Update pre-computed values incrementally
    match &event.payload {
        BankEvent::MoneyTransferred { amount, date, .. } => {
            state.balance -= amount;
            *state.daily_totals.entry(*date).or_insert(0) += amount;
        }
        // ...
    }
}
```

### Lazy State Loading

For large states:

```rust
struct LazyState {
    core: AccountCore,           // Always loaded
    history: Option<Box<TransactionHistory>>,  // Load on demand
}

fn handle(&self, mut state: Self::State) -> Result<NewEvents<Self::Event>, CommandError> {
    // Load history only if needed
    if self.requires_history_check() {
        // In practice the executor or state helpers will perform async loads; handle remains focused on business logic.
    }

    // Continue...
    Ok(NewEvents::from(vec![]))
}
```

## Testing Commands

### Unit Testing

```rust
#[test]
fn test_command_stream_declaration() {
    let cmd = TransferMoney {
        from_account: StreamId::from_static("account-1"),
        to_account: StreamId::from_static("account-2"),
        amount: 100,
        reference: "test".to_string(),
    };

    let streams = cmd.stream_declarations();
    assert_eq!(streams.len(), 2);
    assert!(streams.iter().any(|id| id == &StreamId::from_static("account-1")));
    assert!(streams.iter().any(|id| id == &StreamId::from_static("account-2")));
}
```

### Testing State Reconstruction

```rust
#[test]
fn test_apply_events() {
    let cmd = TransferMoney { /* ... */ };
    let mut state = AccountState::default();

    let event = create_test_event(BankEvent::AccountOpened {
        balance: 1000,
        owner: "alice".to_string(),
    });

    cmd.apply(&mut state, &event);

    assert_eq!(state.balance, 1000);
    assert!(state.exists);
}
```

## Common Patterns

### Idempotent Commands

Make commands idempotent by checking for duplicate operations:

```rust
fn handle(/* ... */) -> Result<NewEvents<Self::Event>, CommandError> {
    // Check if operation was already performed
    if state.transfers.contains(&self.reference) {
        // Already processed - return success with no new events
        return Ok(NewEvents::from(vec![]));
    }

    // Process normally...
    Ok(NewEvents::from(vec![]))
}
```

### Command Versioning

Handle command evolution:

```rust
#[derive(Command, Clone)]
#[command(version = 2)]
struct TransferMoneyV2 {
    #[stream]
    from_account: StreamId,

    #[stream]
    to_account: StreamId,

    amount: Money,
    reference: String,

    // New in V2
    category: TransferCategory,
}
```

## Summary

The EventCore command system provides:

- ✅ **Zero boilerplate** through `#[derive(Command)]`
- ✅ **Type-safe stream access** preventing invalid writes
- ✅ **Clear separation** between infrastructure and domain logic
- ✅ **Flexible validation** with the `require!` macro
- ✅ **Extensibility** through the two-trait design

Key takeaways:

1. Use `#[derive(Command)]` to eliminate boilerplate
2. Declare streams with `#[stream]` attributes
3. Implement business logic in `CommandLogic`
4. Leverage type safety for compile-time guarantees
5. Commands are just data - easy to test and reason about

Next, let's explore [Events and Event Stores](./02-events-and-stores.md) →
