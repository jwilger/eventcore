# Tutorial: Using EventCore Macros

EventCore provides powerful macros to reduce boilerplate in command implementations. This tutorial shows you how to use the `#[derive(Command)]` procedural macro and the helper macros `require!` and `emit!`.

## Prerequisites

Add the macro crate to your dependencies:

```toml
[dependencies]
eventcore = "0.1"
eventcore-macros = "0.1"  # For procedural macros
eventcore-memory = "0.1"  # For testing
async-trait = "0.1"
serde = { version = "1.0", features = ["derive"] }
```

## Using `#[derive(Command)]`

The `#[derive(Command)]` macro automatically generates the `Command` trait implementation based on field annotations, significantly reducing boilerplate code.

### Basic Example

```rust
use eventcore_macros::Command;
use eventcore::types::StreamId;
use serde::{Serialize, Deserialize};
use nutype::nutype;

// Define a validated amount type
#[nutype(validate(greater = 0))]
struct Money(u64);

// Events
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
enum BankEvent {
    MoneyTransferred { from: String, to: String, amount: u64 },
}

impl TryFrom<&BankEvent> for BankEvent {
    type Error = std::convert::Infallible;
    fn try_from(value: &BankEvent) -> Result<Self, Self::Error> { Ok(value.clone()) }
}

// Command with automatic trait derivation
#[derive(Command)]
struct TransferMoney {
    #[stream]  // This field contributes to read_streams()
    from_account: StreamId,
    
    #[stream]  // This field also contributes to read_streams()
    to_account: StreamId,
    
    amount: Money,  // Regular field, not a stream
    reference: String,
}
```

**What the macro generates:**
- `TransferMoneyStreamSet` phantom type for compile-time stream access control
- `read_streams()` implementation that returns `[from_account, to_account]`
- Automatic stream access validation

### Using the Generated Command

```rust
use eventcore::prelude::*;

#[async_trait]
impl Command for TransferMoney {
    type Input = Self;  // The struct itself is the input
    type State = TransferState;
    type Event = BankEvent;
    type StreamSet = TransferMoneyStreamSet;  // Generated by macro

    // read_streams() is auto-generated by the macro
    
    fn apply(&self, state: &mut Self::State, event: &StoredEvent<Self::Event>) {
        // Your event folding logic
        match &event.payload {
            BankEvent::MoneyTransferred { from, to, amount } => {
                // Update state...
            }
        }
    }

    async fn handle(
        &self,
        read_streams: ReadStreams<Self::StreamSet>,
        state: Self::State,
        input: Self::Input,
        _stream_resolver: &mut StreamResolver,
    ) -> CommandResult<Vec<StreamWrite<Self::StreamSet, Self::Event>>> {
        // Business logic
        let event = StreamWrite::new(
            &read_streams,
            input.from_account.clone(),
            BankEvent::MoneyTransferred {
                from: input.from_account.to_string(),
                to: input.to_account.to_string(),
                amount: input.amount.into(),
            }
        )?;
        
        Ok(vec![event])
    }
}
```

### Creating and Using the Command

```rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create the command with validation
    let command = TransferMoney {
        from_account: StreamId::try_new("account-alice")?,
        to_account: StreamId::try_new("account-bob")?,
        amount: Money::try_new(1000)?,
        reference: "monthly-payment".to_string(),
    };
    
    let event_store = InMemoryEventStore::<BankEvent>::new();
    let executor = CommandExecutor::new(event_store);
    
    // Execute with the command as its own input
    let result = executor.execute(&command, command, ExecutionOptions::default()).await?;
    println!("âœ… Transfer completed! {} events written", result.events_written.len());
    
    Ok(())
}
```

## Helper Macros

EventCore provides two helper macros that work with the `#[derive(Command)]` procedural macro to reduce boilerplate in command implementations.

### `require!(condition, message)`

Validates business rules and returns an error if the condition is false:

```rust
use eventcore::require;

async fn handle(
    &self,
    read_streams: ReadStreams<Self::StreamSet>,
    state: Self::State,
    input: Self::Input,
    stream_resolver: &mut StreamResolver,
) -> CommandResult<Vec<StreamWrite<Self::StreamSet, Self::Event>>> {
    require!(input.amount > 0, "Amount must be positive");
    require!(state.account_exists, "Account must exist");
    require!(state.balance >= input.amount, "Insufficient funds");
    
    // ... rest of business logic
}
```

### `emit!(events, read_streams, stream, event)`

Creates events with compile-time stream access validation:

```rust
use eventcore::emit;

async fn handle(
    &self,
    read_streams: ReadStreams<Self::StreamSet>,
    state: Self::State,
    input: Self::Input,
    stream_resolver: &mut StreamResolver,
) -> CommandResult<Vec<StreamWrite<Self::StreamSet, Self::Event>>> {
    let mut events = Vec::new();
    
    emit!(events, &read_streams, input.account_id, AccountEvent::Deposited {
        amount: input.amount,
    });
    
    // Conditional events
    if input.amount > 1000 {
        emit!(events, &read_streams, audit_stream(), AuditEvent::LargeTransaction {
            account: input.account_id.clone(),
            amount: input.amount,
        });
    }
    
    Ok(events)
}
```

## Comparison: Manual vs Derive Macro Approaches

### Manual Implementation (verbose but explicit)
```rust
struct TransferMoney {
    from_account: StreamId,
    to_account: StreamId,
    amount: u64,
}

#[async_trait]
impl Command for TransferMoney {
    type Input = TransferMoneyInput;
    type State = TransferState;
    type Event = BankEvent;
    type StreamSet = ();

    fn read_streams(&self, input: &Self::Input) -> Vec<StreamId> {
        vec![input.from_account.clone(), input.to_account.clone()]
    }

    fn apply(&self, state: &mut Self::State, event: &StoredEvent<Self::Event>) {
        // ... manual implementation
    }

    async fn handle(&self, ...) -> CommandResult<Vec<StreamWrite<...>>> {
        // ... manual implementation
    }
}
```

### Derive Macro Implementation (concise with generated boilerplate)
```rust
#[derive(Command)]
struct TransferMoney {
    #[stream]
    from_account: StreamId,
    #[stream]
    to_account: StreamId,
    amount: u64,
}

// Only need to implement the business logic methods:
#[async_trait]
impl Command for TransferMoney {
    type Input = Self;
    type State = TransferState;
    type Event = BankEvent;
    type StreamSet = TransferMoneyStreamSet; // Generated by macro

    // read_streams() is auto-generated
    
    fn apply(&self, state: &mut Self::State, event: &StoredEvent<Self::Event>) {
        // Your event folding logic
    }

    async fn handle(&self, ...) -> CommandResult<Vec<StreamWrite<...>>> {
        // Your business logic with require! and emit! helpers
    }
}
```

## Best Practices

### When to Use Each Approach

**Use `#[derive(Command)]` when:**
- You want reduced boilerplate for stream declarations
- You prefer explicit trait implementations for business logic
- You need type-safe stream access without repetitive `read_streams()` implementations

**Use manual implementation when:**
- You need maximum control over every aspect of the command
- You're debugging complex command interactions
- You're gradually migrating existing code

### Naming Conventions

```rust
// Commands use imperative verb + noun
#[derive(Command)]
struct TransferMoney { ... }

#[derive(Command)]
struct OpenAccount { ... }

#[derive(Command)]
struct CancelOrder { ... }

// Events use past tense
enum BankEvent {
    MoneyTransferred { ... },
    AccountOpened { ... },
    OrderCancelled { ... },
}
```

### Stream Field Patterns

```rust
#[derive(Command)]
struct ProcessOrder {
    // Primary entity stream
    #[stream]
    order_stream: StreamId,
    
    // Related entity streams
    #[stream]
    customer_stream: StreamId,
    #[stream]
    inventory_stream: StreamId,
    
    // Non-stream fields
    processing_notes: String,
    operator_id: String,
}
```

## Testing Derive Macro Commands

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_derive_macro_command() {
        let command = TransferMoney {
            from_account: StreamId::try_new("from").unwrap(),
            to_account: StreamId::try_new("to").unwrap(),
            amount: 100,
        };
        
        // Test that streams are correctly identified by the derive macro
        let streams = command.read_streams(&command);
        assert_eq!(streams.len(), 2);
        assert!(streams.contains(&StreamId::try_new("from").unwrap()));
        assert!(streams.contains(&StreamId::try_new("to").unwrap()));
    }
    
    #[test]
    fn test_helper_macros() {
        // The require! and emit! macros should work correctly
        // This would be tested within the command execution
    }
}
```

## Advanced Patterns

### Dynamic Stream Discovery with Helper Macros

```rust
#[derive(Command)]
struct ProcessBulkOrder {
    #[stream]
    order_stream: StreamId,
    #[stream] 
    customer_stream: StreamId,
    
    item_ids: Vec<String>,
}

#[async_trait]
impl Command for ProcessBulkOrder {
    // ... other trait implementations
    
    async fn handle(
        &self,
        read_streams: ReadStreams<Self::StreamSet>,
        state: Self::State,
        input: Self::Input,
        stream_resolver: &mut StreamResolver,
    ) -> CommandResult<Vec<StreamWrite<Self::StreamSet, Self::Event>>> {
        // Dynamically add product streams for each item
        let product_streams: Vec<StreamId> = input.item_ids.iter()
            .map(|id| StreamId::try_new(format!("product-{}", id)).unwrap())
            .collect();
            
        stream_resolver.add_streams(product_streams);
        
        // The executor will re-read with expanded stream set
        // and call handle() again with complete state
        
        let mut events = Vec::new();
        // Process with full state using emit! helper...
        Ok(events)
    }
}
```

### Conditional Event Generation

```rust
async fn handle(
    &self,
    read_streams: ReadStreams<Self::StreamSet>,
    state: Self::State,
    input: Self::Input,
    stream_resolver: &mut StreamResolver,
) -> CommandResult<Vec<StreamWrite<Self::StreamSet, Self::Event>>> {
    let mut events = Vec::new();
    
    // Always emit the main event
    emit!(events, &read_streams, input.account_id, AccountEvent::Deposited {
        amount: input.amount,
    });
    
    // Conditional audit event for large amounts
    if input.amount > 10000 {
        require!(state.is_verified, "Large deposits require verified accounts");
        
        emit!(events, &read_streams, audit_stream(), AuditEvent::LargeDeposit {
            account: input.account_id.clone(),
            amount: input.amount,
            timestamp: Timestamp::now(),
        });
    }
    
    Ok(events)
}
```

EventCore's derive macro and helper macros make commands more maintainable and less error-prone while preserving the full power of the type-safe command system. The `#[derive(Command)]` macro eliminates stream declaration boilerplate, while `require!` and `emit!` helpers reduce business logic verbosity. Choose between manual implementation for maximum control or derive macros for reduced boilerplate, based on your team's preferences and requirements.