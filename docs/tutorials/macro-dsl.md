# Tutorial: Using the Macro DSL

EventCore provides powerful macros to reduce boilerplate and make command definitions more declarative. This tutorial shows you how to use both the `#[derive(Command)]` macro and the declarative `command!` macro.

## Prerequisites

Add the macro crate to your dependencies:

```toml
[dependencies]
eventcore = "0.1"
eventcore-macros = "0.1"  # For procedural macros
eventcore-memory = "0.1"  # For testing
async-trait = "0.1"
serde = { version = "1.0", features = ["derive"] }
```

## Approach 1: Using `#[derive(Command)]`

The `#[derive(Command)]` macro automatically generates the `Command` trait implementation based on field annotations.

### Basic Example

```rust
use eventcore_macros::Command;
use eventcore::types::StreamId;
use serde::{Serialize, Deserialize};
use nutype::nutype;

// Define a validated amount type
#[nutype(validate(greater = 0))]
struct Money(u64);

// Events
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
enum BankEvent {
    MoneyTransferred { from: String, to: String, amount: u64 },
}

impl TryFrom<&BankEvent> for BankEvent {
    type Error = std::convert::Infallible;
    fn try_from(value: &BankEvent) -> Result<Self, Self::Error> { Ok(value.clone()) }
}

// Command with automatic trait derivation
#[derive(Command)]
struct TransferMoney {
    #[stream]  // This field contributes to read_streams()
    from_account: StreamId,
    
    #[stream]  // This field also contributes to read_streams()
    to_account: StreamId,
    
    amount: Money,  // Regular field, not a stream
    reference: String,
}
```

**What the macro generates:**
- `TransferMoneyStreamSet` phantom type for compile-time stream access control
- `read_streams()` implementation that returns `[from_account, to_account]`
- Automatic stream access validation

### Using the Generated Command

```rust
use eventcore::prelude::*;

#[async_trait]
impl Command for TransferMoney {
    type Input = Self;  // The struct itself is the input
    type State = TransferState;
    type Event = BankEvent;
    type StreamSet = TransferMoneyStreamSet;  // Generated by macro

    // read_streams() is auto-generated by the macro
    
    fn apply(&self, state: &mut Self::State, event: &StoredEvent<Self::Event>) {
        // Your event folding logic
        match &event.payload {
            BankEvent::MoneyTransferred { from, to, amount } => {
                // Update state...
            }
        }
    }

    async fn handle(
        &self,
        read_streams: ReadStreams<Self::StreamSet>,
        state: Self::State,
        input: Self::Input,
        _stream_resolver: &mut StreamResolver,
    ) -> CommandResult<Vec<StreamWrite<Self::StreamSet, Self::Event>>> {
        // Business logic
        let event = StreamWrite::new(
            &read_streams,
            input.from_account.clone(),
            BankEvent::MoneyTransferred {
                from: input.from_account.to_string(),
                to: input.to_account.to_string(),
                amount: input.amount.into(),
            }
        )?;
        
        Ok(vec![event])
    }
}
```

### Creating and Using the Command

```rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create the command with validation
    let command = TransferMoney {
        from_account: StreamId::try_new("account-alice")?,
        to_account: StreamId::try_new("account-bob")?,
        amount: Money::try_new(1000)?,
        reference: "monthly-payment".to_string(),
    };
    
    let event_store = InMemoryEventStore::<BankEvent>::new();
    let executor = CommandExecutor::new(event_store);
    
    // Execute with the command as its own input
    let result = executor.execute(&command, command, ExecutionOptions::default()).await?;
    println!("âœ… Transfer completed! {} events written", result.events_written.len());
    
    Ok(())
}
```

## Approach 2: Using the `command!` Macro

The `command!` macro provides a more declarative syntax for defining commands entirely in one place.

### Basic Command Definition

```rust
use eventcore::{command, require, emit};
use eventcore::types::StreamId;
use std::collections::HashMap;

command! {
    /// Transfer money between two accounts
    TransferMoneyV2 {
        // Fields marked with 'reads:' contribute to the consistency boundary
        reads: from_account: StreamId,
        reads: to_account: StreamId,
        
        // Regular fields
        amount: u64,
        reference: String,
    }
    
    // Define the state type
    state: TransferStateV2 {
        accounts: HashMap<StreamId, (bool, u64)>, // (exists, balance)
    }
    
    // Define how events are folded into state
    apply(state, event) {
        match event.payload {
            BankEvent::AccountOpened { initial_balance, .. } => {
                state.accounts.insert(event.stream_id.clone(), (true, initial_balance));
            }
            BankEvent::MoneyTransferred { amount, .. } => {
                // Update balances based on stream
                if let Some((exists, balance)) = state.accounts.get_mut(&event.stream_id) {
                    // This is simplified - you'd need more logic to determine debit vs credit
                }
            }
        }
    }
    
    // Define the business logic
    handle(read_streams, state, input, stream_resolver) -> Vec<StreamWrite<_, BankEvent>> {
        // Use require! for business rule validation
        let from_balance = state.accounts.get(&input.from_account)
            .map(|(exists, balance)| if *exists { *balance } else { 0 })
            .unwrap_or(0);
            
        require!(from_balance >= input.amount, "Insufficient funds");
        
        let to_exists = state.accounts.get(&input.to_account)
            .map(|(exists, _)| *exists)
            .unwrap_or(false);
            
        require!(to_exists, "Destination account does not exist");
        
        let mut events = Vec::new();
        
        // Use emit! for creating events with type-safe stream access
        emit!(events, read_streams, input.from_account, BankEvent::MoneyTransferred {
            from: input.from_account.to_string(),
            to: input.to_account.to_string(),
            amount: input.amount,
        });
        
        emit!(events, read_streams, input.to_account, BankEvent::MoneyTransferred {
            from: input.from_account.to_string(),
            to: input.to_account.to_string(),
            amount: input.amount,
        });
        
        events
    }
}
```

### Macro Helper Functions

The `command!` macro provides several helper functions:

#### `require!(condition, message)`
Validates business rules and returns an error if the condition is false:

```rust
handle(read_streams, state, input, stream_resolver) {
    require!(input.amount > 0, "Amount must be positive");
    require!(state.account_exists, "Account must exist");
    require!(state.balance >= input.amount, "Insufficient funds");
    
    // ... rest of logic
}
```

#### `emit!(events, read_streams, stream, event)`
Creates events with compile-time stream access validation:

```rust
handle(read_streams, state, input, stream_resolver) {
    let mut events = Vec::new();
    
    emit!(events, read_streams, input.account_id, AccountEvent::Deposited {
        amount: input.amount,
    });
    
    // Conditional events
    if input.amount > 1000 {
        emit!(events, read_streams, audit_stream, AuditEvent::LargeTransaction {
            account: input.account_id.clone(),
            amount: input.amount,
        });
    }
    
    events
}
```

### Advanced Macro Features

#### Optional Fields and Defaults

```rust
command! {
    CreateOrder {
        reads: customer_stream: StreamId,
        reads: product_stream: StreamId,
        
        quantity: u32,
        
        // Optional field with default
        priority: Option<String> = None,
        
        // Field with custom default
        created_at: Timestamp = Timestamp::now(),
    }
    
    // ... rest of definition
}
```

#### Read-Only Commands

For commands that only read data (queries):

```rust
command! {
    GetAccountBalance {
        reads: account_id: StreamId,
        
        // Mark as read-only to skip event generation
        read_only: true,
    }
    
    state: AccountState {
        balance: u64,
        exists: bool,
    }
    
    apply(state, event) {
        match event.payload {
            BankEvent::AccountOpened { initial_balance, .. } => {
                state.exists = true;
                state.balance = initial_balance;
            }
            BankEvent::MoneyDeposited { amount } => {
                state.balance += amount;
            }
            BankEvent::MoneyWithdrawn { amount } => {
                state.balance = state.balance.saturating_sub(amount);
            }
        }
    }
    
    handle(read_streams, state, input, stream_resolver) -> Vec<StreamWrite<_, BankEvent>> {
        // For read-only commands, typically you'd return query results
        // through a different mechanism (not events)
        println!("Account {} balance: {}", input.account_id, state.balance);
        vec![] // No events for read-only commands
    }
}
```

## Comparison: Manual vs Macro Approaches

### Manual Implementation (verbose but explicit)
```rust
struct TransferMoney {
    from_account: StreamId,
    to_account: StreamId,
    amount: u64,
}

#[async_trait]
impl Command for TransferMoney {
    type Input = TransferMoneyInput;
    type State = TransferState;
    type Event = BankEvent;
    type StreamSet = ();

    fn read_streams(&self, input: &Self::Input) -> Vec<StreamId> {
        vec![input.from_account.clone(), input.to_account.clone()]
    }

    fn apply(&self, state: &mut Self::State, event: &StoredEvent<Self::Event>) {
        // ... manual implementation
    }

    async fn handle(&self, ...) -> CommandResult<Vec<StreamWrite<...>>> {
        // ... manual implementation
    }
}
```

### Macro Implementation (concise and declarative)
```rust
command! {
    TransferMoney {
        reads: from_account: StreamId,
        reads: to_account: StreamId,
        amount: u64,
    }
    
    state: TransferState { /* ... */ }
    apply(state, event) { /* ... */ }
    handle(read_streams, state, input, stream_resolver) { /* ... */ }
}
```

## Best Practices

### When to Use Each Approach

**Use `#[derive(Command)]` when:**
- You want to keep the manual `apply()` and `handle()` implementations
- You need maximum control over the implementation
- You're gradually migrating from manual implementations

**Use `command!` macro when:**
- You want the most concise syntax
- You're starting fresh with new commands
- You want to leverage the helper functions (`require!`, `emit!`)

### Naming Conventions

```rust
// Commands use imperative verb + noun
command! { TransferMoney { ... } }
command! { OpenAccount { ... } }
command! { CancelOrder { ... } }

// Events use past tense
enum BankEvent {
    MoneyTransferred { ... },
    AccountOpened { ... },
    OrderCancelled { ... },
}
```

### Stream Field Patterns

```rust
command! {
    ProcessOrder {
        // Primary entity stream
        reads: order_stream: StreamId,
        
        // Related entity streams
        reads: customer_stream: StreamId,
        reads: inventory_stream: StreamId,
        
        // Non-stream fields
        processing_notes: String,
        operator_id: String,
    }
}
```

## Testing Macro-Generated Commands

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_macro_command() {
        let command = TransferMoneyV2 {
            from_account: StreamId::try_new("from").unwrap(),
            to_account: StreamId::try_new("to").unwrap(),
            amount: 100,
            reference: "test".to_string(),
        };
        
        // Test that streams are correctly identified
        let streams = command.read_streams(&command);
        assert_eq!(streams.len(), 2);
        assert!(streams.contains(&StreamId::try_new("from").unwrap()));
        assert!(streams.contains(&StreamId::try_new("to").unwrap()));
    }
    
    #[test]
    fn test_require_macro() {
        // The require! macro should generate appropriate errors
        // This would be tested within the command execution
    }
}
```

## Advanced Patterns

### Dynamic Stream Discovery with Macros

```rust
command! {
    ProcessBulkOrder {
        reads: order_stream: StreamId,
        reads: customer_stream: StreamId,
        
        item_ids: Vec<String>,
    }
    
    handle(read_streams, state, input, stream_resolver) {
        // Dynamically add product streams for each item
        let product_streams: Vec<StreamId> = input.item_ids.iter()
            .map(|id| StreamId::try_new(format!("product-{}", id)).unwrap())
            .collect();
            
        stream_resolver.add_streams(product_streams);
        
        // The executor will re-read with expanded stream set
        // and call handle() again with complete state
        
        let mut events = Vec::new();
        // Process with full state...
        events
    }
}
```

### Conditional Event Generation

```rust
handle(read_streams, state, input, stream_resolver) {
    let mut events = Vec::new();
    
    // Always emit the main event
    emit!(events, read_streams, input.account_id, AccountEvent::Deposited {
        amount: input.amount,
    });
    
    // Conditional audit event for large amounts
    if input.amount > 10000 {
        require!(state.is_verified, "Large deposits require verified accounts");
        
        emit!(events, read_streams, audit_stream(), AuditEvent::LargeDeposit {
            account: input.account_id.clone(),
            amount: input.amount,
            timestamp: Timestamp::now(),
        });
    }
    
    events
}
```

The macro DSL makes EventCore commands more maintainable and less error-prone while preserving the full power of the underlying system. Choose the approach that best fits your team's preferences and requirements.