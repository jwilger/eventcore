# EventCore

[![CI](https://github.com/jwilger/eventcore/workflows/CI/badge.svg)](https://github.com/jwilger/eventcore/actions)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

> **⚠️ EXPERIMENTAL - NOT READY FOR USE**
>
> This project is in early development. APIs are unstable and subject to breaking changes.
> The library is not yet published to crates.io, and referenced packages/examples may be incomplete or non-existent.
>
> **Do not use this in production or depend on it for any real projects.**

A type-safe event sourcing library implementing **multi-stream event sourcing** with dynamic consistency boundaries - commands that can atomically read from and write to multiple event streams.

## Why EventCore?

Traditional event sourcing forces you into rigid aggregate boundaries. EventCore breaks free with:

- **Multi-stream commands**: Read and write multiple streams atomically
- **Type-safe by design**: Illegal states are unrepresentable
- **Dynamic stream discovery**: Commands can discover streams at runtime
- **Zero boilerplate**: No aggregate classes, just commands and events

## Quick Start

> **Note:** The following is a design vision, not current reality. Packages are not yet published.

```toml
# Cargo.toml (EXAMPLE - not yet available on crates.io)
[dependencies]
eventcore = "0.1"
eventcore-postgres = "0.1"  # or your preferred adapter
```

```rust
use eventcore::{prelude::*, require};
use eventcore_macros::{Command, Event};
use eventcore_postgres::PostgresEventStore;
use serde::{Serialize, Deserialize};

// Events use #[derive(Event)] with #[stream] to mark aggregate identity
#[derive(Event, Debug, Clone, Serialize, Deserialize)]
enum BankingEvent {
    MoneyTransferred {
        #[stream]
        from_account: StreamId,
        to_account: StreamId,
        amount: Money,
    },
}

// Commands use #[derive(Command)] with #[stream] to declare required streams
#[derive(Command, Clone)]
struct TransferMoney {
    #[stream]
    from_account: StreamId,
    #[stream]
    to_account: StreamId,
    amount: Money,
}

#[async_trait]
impl CommandLogic for TransferMoney {
    type State = AccountBalances;
    type Event = BankingEvent;
    // type StreamSet is auto-generated by #[derive(Command)] ✅

    fn apply(&self, state: &mut Self::State, event: &StoredEvent<Self::Event>) {
        match &event.payload {
            BankingEvent::MoneyTransferred { from, to, amount } => {
                state.debit(from, *amount);
                state.credit(to, *amount);
            }
        }
    }

    async fn handle(
        &self,
        read_streams: ReadStreams<Self::StreamSet>,
        state: Self::State,
        input: Self::Input,
        _: &mut StreamResolver,
    ) -> CommandResult<Vec<StreamWrite<Self::StreamSet, Self::Event>>> {
        require!(state.balance(&input.from_account) >= input.amount, "Insufficient funds");

        let mut events = vec![];
        emit!(events, &read_streams, input.from_account, BankingEvent::MoneyTransferred {
            from: input.from_account.to_string(),
            to: input.to_account.to_string(),
            amount: input.amount,
        });

        Ok(events)
    }
}

let store = PostgresEventStore::new(config).await?;
let executor = CommandExecutor::new(store);

let command = TransferMoney {
    from_account: StreamId::try_new("account-alice")?,
    to_account: StreamId::try_new("account-bob")?,
    amount: Money::from_cents(10000)?,
};

let result = executor.execute(&command, command).await?;
```

## Key Features

### Type-Safe Stream Access

The `#[derive(Command)]` macro automatically generates boilerplate from `#[stream]` fields:

```rust
#[derive(Command)]
struct TransferMoney {
    #[stream]
    from_account: StreamId,
    #[stream]
    to_account: StreamId,
    amount: Money,
}

// Automatically generates:
// - TransferMoneyStreamSet phantom type for compile-time stream safety
// - Helper method __derive_read_streams() for stream extraction
// - Enables type Input = Self pattern for simple commands
```

### Dynamic Stream Discovery

Some commands only learn about additional streams after inspecting state (e.g., an order references a payment-method stream). Implement `StreamResolver<State>` and return `Some(self)` from `CommandLogic::stream_resolver()` to opt in:

```rust
impl CommandLogic for ProcessPayment {
    type State = CheckoutState;
    type Event = CheckoutEvent;

    fn stream_resolver(&self) -> Option<&dyn StreamResolver<Self::State>> {
        Some(self)
    }

    // apply + handle omitted
}

impl StreamResolver<CheckoutState> for ProcessPayment {
    fn discover_related_streams(&self, state: &CheckoutState) -> Vec<StreamId> {
        state.payment_method_stream.clone().into_iter().collect()
    }
}
```

The executor deduplicates IDs returned by `discover_related_streams`, reads each stream exactly once, and includes every visited stream in the same optimistic concurrency check as the statically declared streams.

### Built-in Concurrency Control

Optimistic locking prevents conflicts automatically. Just execute your commands - version checking and retries are handled transparently.

## Architecture

```
eventcore/              # Core library - traits and types
eventcore-postgres/     # PostgreSQL adapter
eventcore-memory/       # In-memory adapter for testing
eventcore-examples/     # Complete examples
```

## Examples

See [eventcore-examples/](eventcore-examples/) for complete working examples:

- **Banking**: Account transfers with balance tracking
- **E-commerce**: Order workflow with inventory management
- **Sagas**: Order fulfillment with distributed transaction coordination
- **Web Framework Integration**: REST API with Axum (task management system)

## Documentation

- [Core Library](eventcore/README.md) - Types, traits, and patterns
- [PostgreSQL Adapter](eventcore-postgres/README.md) - Production event store
- [Testing Guide](eventcore-memory/README.md) - In-memory store for tests
- [Examples](eventcore-examples/README.md) - Complete applications
- [Web API Examples](eventcore-examples/src/axum_integration_example.rs) - Integration with Axum web framework

### Production Guides

- [Deployment Strategies](docs/manual/06-operations/01-deployment-strategies.md) - Docker, Kubernetes, and cloud deployment
- [Monitoring & Metrics](docs/manual/06-operations/02-monitoring-metrics.md) - Observability and troubleshooting
- [Production Checklist](docs/manual/06-operations/05-production-checklist.md) - Best practices for production
- [Production Configuration Example](examples/production-config.rs) - Best practices for production config

## Development

```bash
# Setup
nix develop              # Enter dev environment
docker-compose up -d     # Start PostgreSQL

# Test
cargo nextest run        # Fast parallel tests
cargo test              # Standard test runner

# Bench
cargo bench             # Performance benchmarks
```

## Performance

Based on current testing with PostgreSQL backend:

- **Single-stream commands**: 86 ops/sec (stable, reliable performance)
- **Multi-stream commands**: Full atomicity operational (estimated 25-50 ops/sec)
- **Batch event writes**: 9,000+ events/sec (excellent bulk throughput)
- **Latency**: P95 ~14ms (database-backed operations)

_Note: Performance optimized for correctness and multi-stream atomicity. See [Performance Report](docs/development-archive/benchmarks/performance-report.md) for detailed benchmarks and system specifications._

## Contributing

EventCore follows strict type-driven development. See [CLAUDE.md](CLAUDE.md) for our development philosophy.

## License

Licensed under the MIT License. See [LICENSE](LICENSE) for details.
